<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Personal Rant of a curious mind]]></title>
  <link href="http://shreyasrk.github.io/atom.xml" rel="self"/>
  <link href="http://shreyasrk.github.io/"/>
  <updated>2014-06-16T09:01:33+05:30</updated>
  <id>http://shreyasrk.github.io/</id>
  <author>
    <name><![CDATA[Shreyas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Software Development]]></title>
    <link href="http://shreyasrk.github.io/blog/2014/06/16/software-development/"/>
    <updated>2014-06-16T08:32:45+05:30</updated>
    <id>http://shreyasrk.github.io/blog/2014/06/16/software-development</id>
    <content type="html"><![CDATA[<p>In my new organization, I&rsquo;m actually beginning to understand the various flavours of developing software and have learnt one thing &ndash; It isn&rsquo;t as easy as it looks to the outside world. There are tons of procedures, processes and responsibilities to look after before the stable product code lies in the hands of the end user. Let me begin to see what goes where.</p>

<p>Say you have a product. Assume you also have a customer in hand. The customer wants a basic flavour of your product to work accroding to it&rsquo;s expectations. That&rsquo;s when you decide to roll out software to him/her. You now tend to phase out various levels of that product so that it doesn&rsquo;t break in the event of the customr&rsquo;s daily interactions with the product &ndash; on any level of intensity, load or any other factor.</p>

<p>You first begin to work on the core features of the product on your own system and build up your own <strong>local</strong> environment. If the product involves a client-server architecture, you ensure all of the components works in your local system first with 127.0.0.1 as your server IP. You write code, attach testcase to them, check if every process of the product works intact with the testcases.  You also load the database locally, test the product with the database and document the procedure. All of this involves just you, nobody else, at the moment. Then, the components begin to split away from themselves, leading to a distributed architecture. More and more people now begin to do the thing that you&rsquo;re doing but all need to be synchronized with data. The database is usually the first part to be installed as a core, distributed entity. All local instances begin to access data corresponding to their won databases from a single point of contact. The load reduces on your local system and thus, you thus have now set up the first local instance of the process.</p>

<p>After the local instance works, you then freeze your code to a version control system &ndash; you tend to submit your code for your peers to test them with their own testcases to delve with. We need an independently running setup of your product somewhere to test this within the organization for all testers to act upon the single system. Thus, enters the build stage of the process, a crucial component which integrates your code with the product and compiles all of the components on a timely basis for synchronization. Testers act on this setup for the reported features/bugs. Thus, the second stage of the process &ndash; <strong>local site</strong> setup is crucial for local changes. Build is run separately for this.</p>

<p>Now that all your code is been tested and is agreed upon, this will be now moved to the third stage &ndash; the developmental stage. The customer sees that the features are now being tested as part of the developmental process. I&rsquo;m a bit hazy on this topic as this is where developers are detached from the system and it is only development team&rsquo;s QA on the customer side take up further testing and keep on releasing bugs/patches to be fixed. They can either be residing in your organization or in the customer&rsquo;s place. Build is run separately.</p>

<p>The fourth stage is where the actual users come into play &ndash; the user acceptance testing phase. A certain belt of your product&rsquo;s users are picked who test it thoroughly as per the customer&rsquo;s requests and keep reporting for any issues. The customer is convinced only in this stage where he gets a real snapshot of the ongoing process of delivery of the requirements. UAT build is again, separate.</p>

<p>Lastly, once everybody agrees that the code works successfully, the final build is run which thus, releases the product into the production stage &ndash; the real field area of usage. All users of the product use it, benefit from it and in turn, help the customer make money.</p>

<p>Certain things get redundant as the code stage begins to rise stagewise. Developers lose role after dev stage, software delivering agent loses role after UAT and customer after production stage. So, if you see that you report a bug/issue in the software and it gets recorded, be patient to see it get fixed according to a timeline. The way the problem is tracked and fixed takes longer so as to not impact the stability, reliaability and value.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hobby Projects Schedule]]></title>
    <link href="http://shreyasrk.github.io/blog/2014/05/21/side-projects-schedule/"/>
    <updated>2014-05-21T09:45:53+05:30</updated>
    <id>http://shreyasrk.github.io/blog/2014/05/21/side-projects-schedule</id>
    <content type="html"><![CDATA[<p>You&rsquo;re a developer. You have work in your office, a tendency to be updated via Twitter/Hacker News, an affinity towards books and sometimes, staying fit. You have a big list of hobby projects to be carried, you need time to learn new stuff and do awesome things. You also have a time-management problem arising with all these. So what will you do to balance things out?</p>

<p>Simple. Move awesomeness to the weekends &ndash; your projects and learning things. Keep reading and news active during weekdays. You won&rsquo;t have the mood to work on these anyway. Plus, news are dull on weekends.</p>

<p>Weekends are the best time for things you love &ndash; 3 nights and 2 days of pure time. Be it coding, learning or er.. movies with a drink.</p>

<p>Finally realized.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traits of a Great Developer]]></title>
    <link href="http://shreyasrk.github.io/blog/2014/05/12/traits-of-a-software-developer/"/>
    <updated>2014-05-12T21:28:49+05:30</updated>
    <id>http://shreyasrk.github.io/blog/2014/05/12/traits-of-a-software-developer</id>
    <content type="html"><![CDATA[<p>What makes you a great software developer? Is it the knowledge of computer Science and mathematics, the awesomeness of showing your flair by doing some cool projects or some inbuilt quality to tweak around, read code and do things accordingly?</p>

<p>None of them, although Math/Computer Science can teach you logical abilities &ndash; one of the fundamental qualities of a developer. I realized it delves down to the four basic things (ingredients, if you may call) that you can be an awesome programmer.</p>

<p>Be a master in the below areas:</p>

<ul>
<li>The operating system that you work in &ndash; Be it the ubercool Linux, buggy Windows or the wannabe Mac, you must know all/most of it&rsquo;s OS commands. And these can be learn only via the terminal/command prompt.</li>
<li>A programming language. Know it in-and-out. Try to work everything of an idea into the same language throughout and see if you can dig out the hidden features of them in the process.</li>
<li>An editor &ndash; vim, emacs, sublime or an IDE of your choice. By good means to know all of it&rsquo;s keyboard shortcuts, the usage of all of it&rsquo;s features and to know how to tweak them.</li>
<li>Your favorite Version control system &ndash; git, svn, mercurial or whatever. Be awesome in a way that you can even teach others in the shortest and quickest way possible.</li>
</ul>


<p>It delves down to only these four. And nothing else. Of course, as time evolves, all of these changes for your choice and hence, it is a recursive loop all over.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up Octopress Blog]]></title>
    <link href="http://shreyasrk.github.io/blog/2014/05/09/setting-up-octopress-blog/"/>
    <updated>2014-05-09T23:24:37+05:30</updated>
    <id>http://shreyasrk.github.io/blog/2014/05/09/setting-up-octopress-blog</id>
    <content type="html"><![CDATA[<p>So, I finally begin to blog again! All thanks to a blogging framework crashed into accidentally, of course.</p>

<p><a href="http://jekyllrb.com/">Jekyll.rb</a> is one powerful micro-blogging framework written in Ruby. It comes with a unique integrator that can easily create, segment and categorize blog posts without hassles. You simply create apost, edit/change, publish and your post is ready. Right in your own site.</p>

<p>Github is advantageous in a lot of ways &ndash; social coding, side projects, open source and cool hacks. It now bumpered with a bonanza &ndash; <a href="https://pages.github.com/">The GitHub Pages</a>. WHat I finally found from the boring wordpress is that, it can be configured, the way we want, the style we like and the site we wish(although, with a site-domain purchase).</p>

<p>Finally, the combination of above turned out to be <a href="http://octopress.org/">Octopress</a>. This is one of the most easiest blog engines, a programmer can fall in love with. Of course, keeping in mind the love of programming but blogging simultaneously. We as programmers tend to do stuff by code all the time and this came as a convenience. What&rsquo;s more is that you can show off keeping your skills intact.</p>

<p>Such engines help in a lot of ways of learning &ndash;</p>

<pre><code>1. A programming language - Ruby.
2. A template engine.
3. Automating posts - the markdown
4. versioning for site and source - git
</code></pre>

<p>Good that if I&rsquo;m just scribbling, I&rsquo;m not just writing stuff up. I&rsquo;m programming too. So, let me begin the new, old journey of blogging back into the life &ndash; with a way I always wanted.</p>

<p>I wanted to add some lines to how to setup your own blog via Octopress too.</p>

<ul>
<li>Get yourself a GitHub user, please. You won&rsquo;t regret.</li>
<li>Setup your site via <a href="https://pages.github.com/">GitHub Site Hosting</a></li>
<li>Install the <a href="http://octopress.org/docs/setup/">Octopress-Jekyll</a> bundle.</li>
<li>Make sure you <a href="http://octopress.org/docs/deploying/github/">deploy your site properly</a></li>
<li>Start Blogging!</li>
</ul>


<p>Now for the missing part. Octopress provides you a clean way of setting up. However, there are some glitches during continuous blogging &ndash; Git might give problems or something will break down so here&rsquo;s my extra findings:</p>

<ul>
<li>When you write/edit posts, first commit the changes</li>
<li>Generate the site using <code>bundle exec rake generate</code> and deploy to <code>master</code> branch via <code>bundle exec rake deploy</code>. This will first add the site.</li>
<li>Push source branch to your repo too (<code>git push origin source</code>). This will ensure you can work anywhere you want with a simple pull/clone.</li>
</ul>


<p>Enjoy!</p>
]]></content>
  </entry>
  
</feed>
